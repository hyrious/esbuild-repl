{
  "version": 3,
  "sources": ["../src/behaviors/editor.ts"],
  "sourcesContent": ["// stolen from github's source code :p\nimport autosize from \"@github/textarea-autosize\";\nimport { observe } from \"selector-observer\";\n\nexport function fire(target: Element, name: string, detail?: any) {\n  return target.dispatchEvent(new CustomEvent(name, { bubbles: true, cancelable: true, detail }));\n}\n\ntype UpdatedText = {\n  text: string;\n  selection: SelectionRange;\n};\n\ntype SelectionRange = [number | null, number | null];\n\nconst INDENTATION_RE = /^(\\s*)/;\nfunction addSortNewLine(\n  text: string,\n  selection: SelectionRange,\n  at: \"here\" | \"begin\" | \"end\"\n): UpdatedText | undefined {\n  const offset = selection[0];\n  if (!offset || !text) return;\n  const selectionEnd = selection[1] || offset;\n\n  const lines = text.slice(0, offset).split(\"\\n\");\n  const currentLine = lines[lines.length - 1];\n  const match = currentLine?.match(INDENTATION_RE);\n  if (!match) return;\n\n  const indentation = match[1] || \"\";\n  const insert = `\\n${indentation}`;\n\n  if (at === \"here\") {\n    return {\n      text: text.slice(0, offset) + insert + text.slice(selectionEnd),\n      selection: [offset + insert.length, selectionEnd + insert.length],\n    };\n  } else if (at === \"begin\") {\n    const begin = offset - currentLine.length;\n    return {\n      text: text.slice(0, begin) + `${indentation}\\n` + text.slice(begin),\n      selection: [begin + indentation.length, begin + indentation.length],\n    };\n  } else {\n    const end_ = text.indexOf(\"\\n\", selectionEnd);\n    const end = end_ < 0 ? text.length : end_;\n    return {\n      text: text.slice(0, end) + insert + text.slice(end),\n      selection: [end + insert.length, end + insert.length],\n    };\n  }\n}\n\nfunction indent(\n  text: string,\n  selection: SelectionRange,\n  substract: boolean\n): UpdatedText | undefined {\n  const selectionStart = selection[0] || 0;\n  const selectionEnd = selection[1] || selectionStart;\n  if (selection[0] === null) return;\n\n  if (selectionStart === selectionEnd) {\n    if (substract) {\n      const lines = text.slice(0, selectionEnd).split(\"\\n\");\n      const currentLine = lines[lines.length - 1];\n      const match = currentLine?.match(INDENTATION_RE);\n      if (!match) return;\n\n      let indentation = match[0];\n      const indent = indentation.length;\n      const lineText = currentLine.slice(indentation.length);\n      indentation = indentation.slice(0, -2);\n      const diff = indent - indentation.length;\n      lines[lines.length - 1] = indentation + lineText;\n\n      return {\n        text: lines.join(\"\\n\") + text.slice(selectionEnd),\n        selection: [selectionEnd - diff, selectionEnd - diff],\n      };\n    } else {\n      return {\n        text: text.slice(0, selectionStart) + \"  \" + text.slice(selectionEnd),\n        selection: [selectionEnd + 2, selectionEnd + 2],\n      };\n    }\n  }\n\n  const startOffset = text.slice(0, selectionStart).lastIndexOf(\"\\n\") + 1;\n  const endOffset_ = text.indexOf(\"\\n\", selectionEnd - 1);\n  const endOffset = endOffset_ > 0 ? endOffset_ : text.length - 1;\n  const selectedLines = text.slice(startOffset, endOffset).split(\"\\n\");\n\n  let startUpdated = false;\n  let selectionStartDiff = 0;\n  let selectionEndDiff = 0;\n  const updatedSelectedLines: string[] = [];\n  for (const line of selectedLines) {\n    const match = line.match(INDENTATION_RE);\n    if (match) {\n      let indentation = match[0];\n      const lineText = line.slice(indentation.length);\n      if (substract) {\n        const prevLength = indentation.length;\n        indentation = indentation.slice(0, -2);\n        selectionStartDiff = startUpdated ? selectionStartDiff : indentation.length - prevLength;\n        startUpdated = true;\n        selectionEndDiff += indentation.length - prevLength;\n      } else {\n        indentation += \"  \";\n        selectionStartDiff = 2;\n        selectionEndDiff += 2;\n      }\n      updatedSelectedLines.push(indentation + lineText);\n    }\n  }\n\n  const linesString = updatedSelectedLines.join(\"\\n\");\n  const newText = text.slice(0, startOffset) + linesString + text.slice(endOffset);\n  const newRange: SelectionRange = [\n    Math.max(startOffset, selectionStart + selectionStartDiff),\n    selectionEnd + selectionEndDiff,\n  ];\n  return { text: newText, selection: newRange };\n}\n\nfunction deselectText(ev: Event) {\n  const event = ev as KeyboardEvent;\n  const element = event.target as HTMLInputElement;\n  if (element.selectionDirection === \"backward\") {\n    element.selectionEnd = element.selectionStart;\n  } else {\n    element.selectionStart = element.selectionEnd;\n  }\n}\n\nlet isIMEVisible = false;\n\nfunction onCompositionStart() {\n  isIMEVisible = true;\n}\n\nfunction onCompositionEnd() {\n  isIMEVisible = false;\n}\n\nfunction updateText(element: HTMLInputElement, result: UpdatedText, event: KeyboardEvent) {\n  element.value = result.text;\n  element.selectionStart = result.selection[0];\n  element.selectionEnd = result.selection[1];\n\n  event.preventDefault();\n  fire(element, \"input\");\n}\n\nfunction handleEnter(ev: Event) {\n  if (isIMEVisible) {\n    return;\n  }\n\n  const event = ev as KeyboardEvent;\n\n  if (event.key === \"Enter\") {\n    const element = event.target as HTMLInputElement;\n\n    let at: \"here\" | \"begin\" | \"end\" | undefined;\n    const ctrl = event.metaKey || event.ctrlKey;\n    const shift = event.shiftKey;\n    if (shift && !ctrl) {\n      at = \"here\";\n    } else if (ctrl && !shift) {\n      at = \"end\";\n    } else if (ctrl && shift) {\n      at = \"begin\";\n    }\n    if (!at) return;\n\n    const result = addSortNewLine(\n      element.value,\n      [element.selectionStart, element.selectionEnd],\n      at\n    );\n    if (result === undefined) return;\n\n    updateText(element, result, event);\n  }\n}\n\n// stolen from refined-github source/features/one-key-formatting.tsx :p\nconst FormattingChars = [\"`\", \"'\", '\"', \"[\", \"(\", \"{\", \"*\", \"_\", \"~\", \"\u201C\", \"\u2018\"];\nconst MatchingChars = [\"`\", \"'\", '\"', \"]\", \")\", \"}\", \"*\", \"_\", \"~\", \"\u201D\", \"\u2019\"];\n\nfunction handleFormat(ev: Event) {\n  if (isIMEVisible) {\n    return;\n  }\n\n  const event = ev as KeyboardEvent;\n\n  if (!FormattingChars.includes(event.key)) {\n    return;\n  }\n\n  const element = event.target as HTMLInputElement;\n\n  const [start, end] = [element.selectionStart, element.selectionEnd];\n\n  if (start === end) {\n    return;\n  }\n\n  const result = wrapSelection(element.value, [start, end], event.key);\n  if (result === undefined) return;\n\n  updateText(element, result, event);\n}\n\nfunction wrapSelection(\n  text: string,\n  [start, end]: SelectionRange,\n  left: string\n): UpdatedText | undefined {\n  if (start == null || end == null || start === end) return;\n\n  const right = MatchingChars[FormattingChars.indexOf(left)];\n  const selection = text.slice(start, end);\n\n  return {\n    text: text.slice(0, start) + left + selection + right + text.slice(end),\n    selection: [start + left.length, end + left.length],\n  };\n}\n\nfunction updateIndentation(ev: Event) {\n  if (isIMEVisible) {\n    return;\n  }\n\n  const event = ev as KeyboardEvent;\n  if (event.key === \"Escape\") {\n    deselectText(ev);\n    return;\n  }\n\n  if (event.key !== \"Tab\") return;\n\n  const element = event.target as HTMLInputElement;\n  const result = indent(\n    element.value,\n    [element.selectionStart, element.selectionEnd],\n    event.shiftKey\n  );\n  if (result === undefined) return;\n\n  updateText(element, result, event);\n}\n\nexport function subscribe(el: Element) {\n  el.addEventListener(\"keydown\", updateIndentation);\n  el.addEventListener(\"keydown\", handleEnter);\n  el.addEventListener(\"keydown\", handleFormat);\n  el.addEventListener(\"compositionstart\", onCompositionStart);\n  el.addEventListener(\"compositionend\", onCompositionEnd);\n  const { unsubscribe } = autosize(el);\n  return {\n    unsubscribe: () => {\n      el.removeEventListener(\"keydown\", updateIndentation);\n      el.removeEventListener(\"keydown\", handleEnter);\n      el.removeEventListener(\"keydown\", handleFormat);\n      el.removeEventListener(\"compositionstart\", onCompositionStart);\n      el.removeEventListener(\"compositionend\", onCompositionEnd);\n      unsubscribe();\n    },\n  };\n}\n\nexport const abortController = observe(\"textarea.editor\", { subscribe });\n"],
  "mappings": "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",
  "names": []
}

{
  "version": 3,
  "sources": ["../src/behaviors/editor.ts"],
  "sourcesContent": ["// stolen from github's source code :p\nimport autosize from \"@github/textarea-autosize\";\nimport { observe } from \"selector-observer\";\n\nexport function fire(target: Element, name: string, detail?: any) {\n  return target.dispatchEvent(new CustomEvent(name, { bubbles: true, cancelable: true, detail }));\n}\n\ntype UpdatedText = {\n  text: string;\n  selection: SelectionRange;\n};\n\ntype SelectionRange = [number | null, number | null];\n\nconst INDENTATION_RE = /^(\\s*)/;\nfunction addSortNewLine(\n  text: string,\n  selection: SelectionRange,\n  at: \"here\" | \"begin\" | \"end\"\n): UpdatedText | undefined {\n  const offset = selection[0];\n  if (!offset || !text) return;\n  const selectionEnd = selection[1] || offset;\n\n  const lines = text.slice(0, offset).split(\"\\n\");\n  const currentLine = lines[lines.length - 1];\n  const match = currentLine?.match(INDENTATION_RE);\n  if (!match) return;\n\n  const indentation = match[1] || \"\";\n  const insert = `\\n${indentation}`;\n\n  if (at === \"here\") {\n    return {\n      text: text.slice(0, offset) + insert + text.slice(selectionEnd),\n      selection: [offset + insert.length, selectionEnd + insert.length],\n    };\n  } else if (at === \"begin\") {\n    const begin = offset - currentLine.length;\n    return {\n      text: text.slice(0, begin) + `${indentation}\\n` + text.slice(begin),\n      selection: [begin + indentation.length, begin + indentation.length],\n    };\n  } else {\n    const end_ = text.indexOf(\"\\n\", selectionEnd);\n    const end = end_ < 0 ? text.length : end_;\n    return {\n      text: text.slice(0, end) + insert + text.slice(end),\n      selection: [end + insert.length, end + insert.length],\n    };\n  }\n}\n\nfunction indent(\n  text: string,\n  selection: SelectionRange,\n  substract: boolean\n): UpdatedText | undefined {\n  const selectionStart = selection[0] || 0;\n  const selectionEnd = selection[1] || selectionStart;\n  if (selection[0] === null) return;\n\n  if (selectionStart === selectionEnd) {\n    if (substract) {\n      const lines = text.slice(0, selectionEnd).split(\"\\n\");\n      const currentLine = lines[lines.length - 1];\n      const match = currentLine?.match(INDENTATION_RE);\n      if (!match) return;\n\n      let indentation = match[0];\n      const indent = indentation.length;\n      const lineText = currentLine.slice(indentation.length);\n      indentation = indentation.slice(0, -2);\n      const diff = indent - indentation.length;\n      lines[lines.length - 1] = indentation + lineText;\n\n      return {\n        text: lines.join(\"\\n\") + text.slice(selectionEnd),\n        selection: [selectionEnd - diff, selectionEnd - diff],\n      };\n    } else {\n      return {\n        text: text.slice(0, selectionStart) + \"  \" + text.slice(selectionEnd),\n        selection: [selectionEnd + 2, selectionEnd + 2],\n      };\n    }\n  }\n\n  const startOffset = text.slice(0, selectionStart).lastIndexOf(\"\\n\") + 1;\n  const endOffset_ = text.indexOf(\"\\n\", selectionEnd - 1);\n  const endOffset = endOffset_ > 0 ? endOffset_ : text.length - 1;\n  const selectedLines = text.slice(startOffset, endOffset).split(\"\\n\");\n\n  let startUpdated = false;\n  let selectionStartDiff = 0;\n  let selectionEndDiff = 0;\n  const updatedSelectedLines: string[] = [];\n  for (const line of selectedLines) {\n    const match = line.match(INDENTATION_RE);\n    if (match) {\n      let indentation = match[0];\n      const lineText = line.slice(indentation.length);\n      if (substract) {\n        const prevLength = indentation.length;\n        indentation = indentation.slice(0, -2);\n        selectionStartDiff = startUpdated ? selectionStartDiff : indentation.length - prevLength;\n        startUpdated = true;\n        selectionEndDiff += indentation.length - prevLength;\n      } else {\n        indentation += \"  \";\n        selectionStartDiff = 2;\n        selectionEndDiff += 2;\n      }\n      updatedSelectedLines.push(indentation + lineText);\n    }\n  }\n\n  const linesString = updatedSelectedLines.join(\"\\n\");\n  const newText = text.slice(0, startOffset) + linesString + text.slice(endOffset);\n  const newRange: SelectionRange = [\n    Math.max(startOffset, selectionStart + selectionStartDiff),\n    selectionEnd + selectionEndDiff,\n  ];\n  return { text: newText, selection: newRange };\n}\n\nfunction deselectText(ev: Event) {\n  const event = ev as KeyboardEvent;\n  const element = event.target as HTMLInputElement;\n  if (element.selectionDirection === \"backward\") {\n    element.selectionEnd = element.selectionStart;\n  } else {\n    element.selectionStart = element.selectionEnd;\n  }\n}\n\nlet isIMEVisible = false;\n\nfunction onCompositionStart() {\n  isIMEVisible = true;\n}\n\nfunction onCompositionEnd() {\n  isIMEVisible = false;\n}\n\nfunction updateText(element: HTMLInputElement, result: UpdatedText, event: KeyboardEvent) {\n  element.value = result.text;\n  element.selectionStart = result.selection[0];\n  element.selectionEnd = result.selection[1];\n\n  event.preventDefault();\n  fire(element, \"input\");\n}\n\nfunction handleEnter(ev: Event) {\n  if (isIMEVisible) {\n    return;\n  }\n\n  const event = ev as KeyboardEvent;\n\n  if (event.key === \"Enter\") {\n    const element = event.target as HTMLInputElement;\n\n    let at: \"here\" | \"begin\" | \"end\" | undefined;\n    const ctrl = event.metaKey || event.ctrlKey;\n    const shift = event.shiftKey;\n    if (shift && !ctrl) {\n      at = \"here\";\n    } else if (ctrl && !shift) {\n      at = \"end\";\n    } else if (ctrl && shift) {\n      at = \"begin\";\n    }\n    if (!at) return;\n\n    const result = addSortNewLine(\n      element.value,\n      [element.selectionStart, element.selectionEnd],\n      at\n    );\n    if (result === undefined) return;\n\n    updateText(element, result, event);\n  }\n}\n\n// stolen from refined-github source/features/one-key-formatting.tsx :p\nconst FormattingChars = [\"`\", \"'\", '\"', \"[\", \"(\", \"{\", \"*\", \"_\", \"~\", \"\u201C\", \"\u2018\"];\nconst MatchingChars = [\"`\", \"'\", '\"', \"]\", \")\", \"}\", \"*\", \"_\", \"~\", \"\u201D\", \"\u2019\"];\n\nfunction handleFormat(ev: Event) {\n  if (isIMEVisible) {\n    return;\n  }\n\n  const event = ev as KeyboardEvent;\n\n  if (!FormattingChars.includes(event.key)) {\n    return;\n  }\n\n  const element = event.target as HTMLInputElement;\n\n  const [start, end] = [element.selectionStart, element.selectionEnd];\n\n  if (start === end) {\n    return;\n  }\n\n  const result = wrapSelection(element.value, [start, end], event.key);\n  if (result === undefined) return;\n\n  updateText(element, result, event);\n}\n\nfunction wrapSelection(\n  text: string,\n  [start, end]: SelectionRange,\n  left: string\n): UpdatedText | undefined {\n  if (start == null || end == null || start === end) return;\n\n  const right = MatchingChars[FormattingChars.indexOf(left)];\n  const selection = text.slice(start, end);\n\n  return {\n    text: text.slice(0, start) + left + selection + right + text.slice(end),\n    selection: [start + left.length, end + left.length],\n  };\n}\n\nfunction updateIndentation(ev: Event) {\n  if (isIMEVisible) {\n    return;\n  }\n\n  const event = ev as KeyboardEvent;\n  if (event.key === \"Escape\") {\n    deselectText(ev);\n    return;\n  }\n\n  if (event.key !== \"Tab\") return;\n\n  const element = event.target as HTMLInputElement;\n  const result = indent(\n    element.value,\n    [element.selectionStart, element.selectionEnd],\n    event.shiftKey\n  );\n  if (result === undefined) return;\n\n  updateText(element, result, event);\n}\n\nexport function subscribe(el: Element) {\n  el.addEventListener(\"keydown\", updateIndentation);\n  el.addEventListener(\"keydown\", handleEnter);\n  el.addEventListener(\"keydown\", handleFormat);\n  el.addEventListener(\"compositionstart\", onCompositionStart);\n  el.addEventListener(\"compositionend\", onCompositionEnd);\n  const { unsubscribe } = autosize(el);\n  return {\n    unsubscribe: () => {\n      el.removeEventListener(\"keydown\", updateIndentation);\n      el.removeEventListener(\"keydown\", handleEnter);\n      el.removeEventListener(\"keydown\", handleFormat);\n      el.removeEventListener(\"compositionstart\", onCompositionStart);\n      el.removeEventListener(\"compositionend\", onCompositionEnd);\n      unsubscribe();\n    },\n  };\n}\n\nexport const abortController = observe(\"textarea.editor\", { subscribe });\n"],
  "mappings": "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",
  "names": ["fire", "target", "name", "detail", "INDENTATION_RE", "addSortNewLine", "text", "selection", "at", "offset", "selectionEnd", "lines", "currentLine", "match", "indentation", "insert", "begin", "end_", "end", "indent", "substract", "selectionStart", "lineText", "diff", "startOffset", "endOffset_", "endOffset", "selectedLines", "startUpdated", "selectionStartDiff", "selectionEndDiff", "updatedSelectedLines", "line", "prevLength", "linesString", "newText", "newRange", "deselectText", "ev", "element", "isIMEVisible", "onCompositionStart", "onCompositionEnd", "updateText", "result", "event", "handleEnter", "ctrl", "shift", "FormattingChars", "MatchingChars", "handleFormat", "start", "wrapSelection", "left", "right", "updateIndentation", "subscribe", "el", "unsubscribe", "autosize", "abortController", "observe"]
}
